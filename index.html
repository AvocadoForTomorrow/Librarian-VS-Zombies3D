<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Freyja vs Zombies 3D</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    /* Overlay for puzzle mode */
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      z-index: 10;
    }
    #overlay input {
      font-size: 24px;
      padding: 8px;
      margin: 10px;
    }
    #overlay button {
      font-size: 24px;
      padding: 8px 16px;
      margin: 10px;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="questionContainer">
      <div id="questionText" style="font-size: 32px; margin-bottom: 20px;"></div>
      <input type="text" id="answerInput" placeholder="Your answer" />
      <div id="timerText" style="font-size: 28px; margin-top: 20px;"></div>
      <button id="submitAnswer">Submit Answer</button>
    </div>
    <div id="message" style="font-size: 36px; margin-top: 20px;"></div>
  </div>
  <!-- Load Three.js and PointerLockControls from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r136/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/PointerLockControls.js"></script>
  <script>
    // === Global Variables ===
    let scene, camera, renderer, controls;
    let clock = new THREE.Clock();
    let objects = [];  // Bookshelves and obstacles
    let zombies = [];  // Array of zombie meshes
    let terminal;      // The terminal block
    let gameState = 'play'; // 'play', 'puzzle', 'gameover', 'win'
    let puzzleData = {
      questions: [],
      current: 0,
      startTime: 0,
      timeLimit: 60 // seconds
    };

    // === Initialize Scene ===
    init();
    animate();

    function init() {
      // Create scene and camera
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xaaaaaa);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
      camera.position.set(0, 20, 0); // Eye height
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Lights
      let ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      let directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(100, 200, 50);
      scene.add(directional);
      
      // Set up PointerLockControls for first-person view
      controls = new THREE.PointerLockControls(camera, renderer.domElement);
      scene.add(controls.getObject());
      document.addEventListener('click', () => {
        if (gameState === 'play') controls.lock();
      });
      
      // Floor
      let floorGeom = new THREE.PlaneGeometry(1000, 1000);
      let floorMat = new THREE.MeshPhongMaterial({ color: 0x808080 });
      let floor = new THREE.Mesh(floorGeom, floorMat);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);
      
      // Hard border around gameplay area (wireframe box)
      let borderGeom = new THREE.BoxGeometry(500, 50, 500);
      let borderMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true });
      let border = new THREE.Mesh(borderGeom, borderMat);
      border.position.y = 25;
      scene.add(border);
      
      // Bookshelves: Create many random boxes as bookshelves
      for (let i = 0; i < 30; i++) {
        let width = THREE.MathUtils.randFloat(20, 50);
        let height = THREE.MathUtils.randFloat(50, 150);
        let depth = THREE.MathUtils.randFloat(10, 30);
        let shelfGeom = new THREE.BoxGeometry(width, height, depth);
        let shelfMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
        let shelf = new THREE.Mesh(shelfGeom, shelfMat);
        shelf.position.x = THREE.MathUtils.randFloatSpread(400);
        shelf.position.z = THREE.MathUtils.randFloatSpread(400);
        shelf.position.y = height / 2;
        scene.add(shelf);
        objects.push(shelf);
      }
      
      // Terminal: 3D block goal (green cube)
      let termGeom = new THREE.BoxGeometry(50, 50, 50);
      let termMat = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
      terminal = new THREE.Mesh(termGeom, termMat);
      terminal.position.set(200, 25, -200);
      scene.add(terminal);
      
      // Zombies: Simple red boxes (humanoid shape) that chase the player.
      for (let i = 0; i < 5; i++) {
        let zombieGeom = new THREE.BoxGeometry(30, 60, 30);
        let zombieMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        let zombie = new THREE.Mesh(zombieGeom, zombieMat);
        zombie.position.x = THREE.MathUtils.randFloatSpread(400);
        zombie.position.z = THREE.MathUtils.randFloatSpread(400);
        zombie.position.y = 30;
        scene.add(zombie);
        zombies.push(zombie);
      }
      
      // Player arms/hands: Attach simple geometry to the camera.
      let arms = new THREE.Group();
      // Left arm
      let leftArmGeom = new THREE.BoxGeometry(10, 30, 10);
      let leftArmMat = new THREE.MeshPhongMaterial({ color: 0xdddddd });
      let leftArm = new THREE.Mesh(leftArmGeom, leftArmMat);
      leftArm.position.set(-20, -10, -30);
      arms.add(leftArm);
      // Right arm
      let rightArmGeom = new THREE.BoxGeometry(10, 30, 10);
      let rightArmMat = new THREE.MeshPhongMaterial({ color: 0xdddddd });
      let rightArm = new THREE.Mesh(rightArmGeom, rightArmMat);
      rightArm.position.set(20, -10, -30);
      arms.add(rightArm);
      // Book in right hand
      let bookGeom = new THREE.BoxGeometry(15, 5, 20);
      let bookMat = new THREE.MeshPhongMaterial({ color: 0x0000ff });
      let book = new THREE.Mesh(bookGeom, bookMat);
      book.position.set(20, -10, -40);
      arms.add(book);
      camera.add(arms);
      
      // Setup window resize
      window.addEventListener('resize', onWindowResize, false);
      
      // Setup puzzle overlay (hidden initially)
      setupOverlay();
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // === Animation Loop ===
    function animate() {
      requestAnimationFrame(animate);
      let delta = clock.getDelta();
      
      if (gameState === 'play') {
        updatePlayer();
        updateZombies(delta);
        checkCollisions();
      } else if (gameState === 'puzzle') {
        updatePuzzleTimer();
      }
      
      renderer.render(scene, camera);
    }
    
    // === Update Functions ===
    function updatePlayer() {
      // First, check if there's any touch/pointer input
      if (renderer.domElement.pointerLockElement === renderer.domElement) {
        // PointerLockControls already updates the camera with mouse movement.
        // For movement, we listen for key presses.
        // (You might add WASD movement here if desired.)
      }
    }
    
    function updateZombies(delta) {
      zombies.forEach(zombie => {
        let direction = new THREE.Vector3();
        direction.subVectors(controls.getObject().position, zombie.position);
        direction.normalize();
        zombie.position.addScaledVector(direction, delta * 50); // Zombie speed
      });
    }
    
    function checkCollisions() {
      let playerPos = controls.getObject().position;
      // If close to terminal, enter puzzle mode.
      if (playerPos.distanceTo(terminal.position) < 30) {
        enterPuzzleMode();
      }
      // If any zombie is too close, game over.
      zombies.forEach(zombie => {
        if (playerPos.distanceTo(zombie.position) < 20) {
          gameOver();
        }
      });
    }
    
    function gameOver() {
      gameState = 'gameover';
      showOverlay("Game Over! Press Y to Restart, N to Quit.");
      document.addEventListener('keydown', handleGameOverInput);
    }
    
    function handleGameOverInput(e) {
      if (e.key.toLowerCase() === 'y') {
        location.reload();
      } else if (e.key.toLowerCase() === 'n') {
        showOverlay("Thanks for playing!");
      }
    }
    
    function enterPuzzleMode() {
      if (gameState !== 'play') return;
      gameState = 'puzzle';
      controls.unlock();
      startPuzzle();
    }
    
    // === Puzzle Overlay Functions ===
    function setupOverlay() {
      let overlay = document.getElementById("overlay");
      overlay.style.display = "none";
      document.getElementById("submitAnswer").addEventListener("click", submitAnswer);
      document.getElementById("answerInput").addEventListener("keydown", function(e) {
        if (e.key === "Enter") {
          submitAnswer();
        }
      });
    }
    
    function startPuzzle() {
      // Generate 3 questions
      puzzleData.questions = [];
      for (let i = 0; i < 3; i++) {
        puzzleData.questions.push(generatePuzzleQuestion());
      }
      puzzleData.current = 0;
      puzzleData.startTime = Date.now();
      showPuzzleQuestion();
    }
    
    function generatePuzzleQuestion() {
      let types = ['multiplication', 'sorting', 'word', 'prealgebra'];
      let type = types[Math.floor(Math.random() * types.length)];
      if (type === 'multiplication') {
        let a = Math.floor(Math.random() * 12) + 1;
        let b = Math.floor(Math.random() * 12) + 1;
        return { text: `What is ${a} x ${b}?`, answer: (a * b).toString() };
      } else if (type === 'sorting') {
        let n = 3 + Math.floor(Math.random() * 3);
        let numbers = [];
        for (let i = 0; i < n; i++) {
          numbers.push(Math.floor(Math.random() * 50) + 1);
        }
        let sorted = numbers.slice().sort((a, b) => a - b);
        return { text: `Sort these numbers: ${numbers.join(" ")}`, answer: sorted.join(" ") };
      } else if (type === 'word') {
        let subTypes = ['candy_add', 'candy_sub'];
        let subType = subTypes[Math.floor(Math.random() * subTypes.length)];
        if (subType === 'candy_add') {
          let x = Math.floor(Math.random() * 20) + 1;
          let y = Math.floor(Math.random() * 20) + 1;
          return { text: `If you have ${x} candies and get ${y} more, how many?`, answer: (x + y).toString() };
        } else {
          let x = Math.floor(Math.random() * 20) + 10;
          let y = Math.floor(Math.random() * x) + 1;
          return { text: `If you have ${x} candies and give away ${y}, how many left?`, answer: (x - y).toString() };
        }
      } else { // prealgebra
        let a = Math.floor(Math.random() * 5) + 1;
        let b = Math.floor(Math.random() * 10) + 1;
        let xVal = Math.floor(Math.random() * 10) + 1;
        let c = a * (xVal + b);
        return { text: `Solve for x: ${a}(x + ${b}) = ${c}`, answer: xVal.toString() };
      }
    }
    
    function showPuzzleQuestion() {
      let overlay = document.getElementById("overlay");
      overlay.style.display = "flex";
      document.getElementById("questionText").innerText = puzzleData.questions[puzzleData.current].text;
      document.getElementById("answerInput").value = "";
      updatePuzzleTimer();
    }
    
    function submitAnswer() {
      let input = document.getElementById("answerInput").value.trim();
      if (input === puzzleData.questions[puzzleData.current].answer) {
        puzzleData.current++;
        if (puzzleData.current < puzzleData.questions.length) {
          puzzleData.startTime = Date.now();
          showPuzzleQuestion();
        } else {
          // Puzzle solved, resume game
          document.getElementById("overlay").style.display = "none";
          gameState = 'play';
          controls.lock();
        }
      } else {
        // Wrong answer: game over
        showOverlay("Wrong answer! Game Over. Press Y to Restart, N to Quit.");
        gameState = 'gameover';
        document.addEventListener('keydown', handleGameOverInput);
      }
    }
    
    function updatePuzzleTimer() {
      let overlayTimer = document.getElementById("timerText");
      let elapsed = Math.floor((Date.now() - puzzleData.startTime) / 1000);
      let remaining = Math.max(0, puzzleData.timeLimit - elapsed);
      overlayTimer.innerText = `Time remaining: ${remaining} sec`;
      if (remaining <= 0) {
        showOverlay("Time's up! Game Over. Press Y to Restart, N to Quit.");
        gameState = 'gameover';
        document.addEventListener('keydown', handleGameOverInput);
      }
    }
    
    function updatePuzzle() {
      // Puzzle overlay updates via DOM events.
    }
    
    function showOverlay(message) {
      let overlay = document.getElementById("overlay");
      overlay.style.display = "flex";
      document.getElementById("message").innerText = message;
    }
  </script>
</body>
</html>
